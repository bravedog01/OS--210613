# uCoreå®éªŒæŠ¥å‘Šâ€”lab4

ğŸ€member:2212777 ç‹èˆ’ç‘€ 2212138 å”è‹‡è‹‡ 2210722 å®‰æ¥ ğŸ€

## ç»ƒä¹ 1ï¼šåˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ªè¿›ç¨‹æ§åˆ¶å—ï¼ˆéœ€è¦ç¼–ç ï¼‰

alloc_procå‡½æ•°ï¼ˆä½äºkern/process/proc.cä¸­ï¼‰è´Ÿè´£åˆ†é…å¹¶è¿”å›ä¸€ä¸ªæ–°çš„struct proc_structç»“æ„ï¼Œç”¨äºå­˜å‚¨æ–°å»ºç«‹çš„å†…æ ¸çº¿ç¨‹çš„ç®¡ç†ä¿¡æ¯ã€‚ucoreéœ€è¦å¯¹è¿™ä¸ªç»“æ„è¿›è¡Œæœ€åŸºæœ¬çš„åˆå§‹åŒ–ï¼Œä½ éœ€è¦å®Œæˆè¿™ä¸ªåˆå§‹åŒ–è¿‡ç¨‹ã€‚

è¯·ç®€è¦è¯´æ˜ä½ çš„è®¾è®¡å®ç°è¿‡ç¨‹å¹¶å›ç­”å¦‚ä¸‹é—®é¢˜ï¼š
è¯·è¯´æ˜proc_structä¸­`struct context context`å’Œ`struct trapframe *tf`æˆå‘˜å˜é‡å«ä¹‰å’Œåœ¨æœ¬å®éªŒä¸­çš„ä½œç”¨æ˜¯å•¥ï¼Ÿï¼ˆæç¤ºé€šè¿‡çœ‹ä»£ç å’Œç¼–ç¨‹è°ƒè¯•å¯ä»¥åˆ¤æ–­å‡ºæ¥ï¼‰

**ç­”ï¼š**

##### 1ã€proc_structç»“æ„çš„åˆå§‹åŒ–

```c++
proc->state = PROC_UNINIT; //   è¿›ç¨‹çŠ¶æ€                  
proc->pid = -1;            //è¿›ç¨‹ID
proc->runs = 0;            //è¿›ç¨‹è¿è¡Œæ—¶é—´                  
proc->kstack = -1; 		   //è¿›ç¨‹çš„å†…æ ¸æ ˆ
proc->need_resched = 0;    //èƒ½å¦è¢«è°ƒåº¦  
proc->parent = NULL;       //çº¿ç¨‹çš„çˆ¶çº¿ç¨‹        
proc->mm = NULL;            //çº¿ç¨‹çš„å†…å­˜ç®¡ç†     
proc->cr3 = boot_cr3;        //é¡µè¡¨é¡¹çš„åŸºåœ°å€                 
proc->flags = 0;             //è¿›ç¨‹æ ‡è®°ä½                
memset(proc->name, 0, PROC_NAME_LEN + 1);   //è¿›ç¨‹å 
proc->tf = NULL;             //ä¸­æ–­å¸§                
memset(&proc->context, 0, sizeof(struct context)); //è¿›ç¨‹çŠ¶æ€ä¿å­˜
```

åœ¨**alloc_proc**å‡½æ•°ä¸­ï¼Œåªæ˜¯å¯¹è¿™ä¸ªç»“æ„ä½“è¿›è¡Œåˆå§‹åŒ–ï¼Œåªæ˜¯æ‰¾åˆ°äº†ä¸€å°å—å†…å­˜ç”¨ä»¥è®°å½•è¿›ç¨‹çš„å¿…è¦ä¿¡æ¯ï¼Œå¹¶æ²¡æœ‰å®é™…åˆ†é…è¿™äº›èµ„æºã€‚å¹¶æœªèµ‹äºˆä»»ä½•æœ‰å®é™…æ„ä¹‰çš„å€¼ã€‚æ‰€ä»¥å°†è¿›ç¨‹çŠ¶æ€è®¾ç½®ä¸ºæœªåˆå§‹åŒ–çŠ¶æ€ï¼Œä¹Ÿæ²¡æœ‰åˆ†é…è¿›ç¨‹idï¼Œå†…æ ¸æ ˆçš„ä½ç½®ç­‰ã€‚**å°†cr3å¯„å­˜å™¨è®¾ç½®æˆå†…æ ¸çš„cr3å¯„å­˜å™¨çš„å€¼ï¼Œæ˜¯å› ä¸ºåœ¨å†…æ ¸ä¸­çš„æ‰€æœ‰å†…æ ¸çº¿ç¨‹éƒ½å…±äº«åŒä¸€å—å†…æ ¸å†…å­˜ç©ºé—´ã€‚**

##### 2ã€proc_structä¸­`struct context context`å’Œ`struct trapframe *tf`æˆå‘˜å˜é‡å«ä¹‰

* åœ¨å®éªŒä¸­çš„ä½œç”¨ï¼š
  * `struct context context`ï¼šå‚¨å­˜è¿›ç¨‹å½“å‰çŠ¶æ€ï¼Œ==ç”¨äºè¿›ç¨‹åˆ‡æ¢ä¸­ä¸Šä¸‹æ–‡çš„ä¿å­˜ä¸æ¢å¤ã€‚==
    * ä¸`trapframe`æ‰€ä¿å­˜çš„ç”¨æˆ·æ€ä¸Šä¸‹æ–‡ä¸åŒï¼Œcontextä¿å­˜çš„æ˜¯çº¿ç¨‹çš„**å½“å‰**ä¸Šä¸‹æ–‡ã€‚è¿™ä¸ªä¸Šä¸‹æ–‡å¯èƒ½æ˜¯æ‰§è¡Œç”¨æˆ·ä»£ç æ—¶çš„ä¸Šä¸‹æ–‡ï¼Œä¹Ÿå¯èƒ½æ˜¯æ‰§è¡Œå†…æ ¸ä»£ç æ—¶çš„ä¸Šä¸‹æ–‡ã€‚ åœ¨`switch to`å‡½æ•°ä¸­ä½¿ç”¨ã€‚
  * `struct trapframe *tf`ï¼šå‚¨å­˜è¿›ç¨‹åœ¨ç”¨æˆ·æ€è¿è¡Œçš„çŠ¶æ€ï¼Œ==ç”¨äºå›åˆ°ç”¨æˆ·æ€æ—¶çš„çŠ¶æ€åˆ‡æ¢==ã€‚
    * æ— è®ºæ˜¯ç”¨æˆ·ç¨‹åºåœ¨ç”¨æˆ·æ€é€šè¿‡ç³»ç»Ÿè°ƒç”¨è¿›å…¥å†…æ ¸æ€ï¼Œè¿˜æ˜¯çº¿ç¨‹åœ¨å†…æ ¸æ€ä¸­è¢«åˆ›å»ºï¼Œå†…æ ¸æ€ä¸­çš„çº¿ç¨‹è¿”å›ç”¨æˆ·æ€æ‰€åŠ è½½çš„ä¸Šä¸‹æ–‡å°±æ˜¯`struct trapframe* tf`ã€‚ æ‰€ä»¥å½“ä¸€ä¸ªçº¿ç¨‹åœ¨å†…æ ¸æ€ä¸­å»ºç«‹ï¼Œåˆ™è¯¥æ–°çº¿ç¨‹å°±å¿…é¡»ä¼ªé€ ä¸€ä¸ª`trapframe`æ¥è¿”å›ç”¨æˆ·æ€ã€‚

* æˆå‘˜å˜é‡å«ä¹‰

  * `struct context context`

    ```c
    struct context {
        uintptr_t ra;
        uintptr_t sp;
        uintptr_t s0;
        uintptr_t s1;
        uintptr_t s2;
        uintptr_t s3;
        uintptr_t s4;
        uintptr_t s5;
        uintptr_t s6;
        uintptr_t s7;
        uintptr_t s8;
        uintptr_t s9;
        uintptr_t s10;
        uintptr_t s11;
    };
    ```

    contextä¸­ä¸»è¦æ˜¯å…³é”®å¯„å­˜å™¨çš„å€¼ã€‚raæ˜¯è¿”å›åœ°å€ï¼Œspæ˜¯æ ˆé¡¶æŒ‡é’ˆã€‚å‰©ä½™12ä¸ªå¯„å­˜å™¨ä¿å­˜çš„æ˜¯è¿›ç¨‹çŠ¶æ€ï¼Œæ–¹ä¾¿è¿›ç¨‹åˆ‡æ¢æ—¶æ¢å¤çŠ¶æ€ã€‚

  * `struct trapframe *tf`

    ```c
    struct trapframe {
        struct pushregs gpr;//å¯„å­˜å™¨
        uintptr_t status;//çŠ¶æ€å¯„å­˜å™¨
        uintptr_t epc;//ä¿å­˜å‘ç”Ÿä¸­æ–­æ—¶çš„æŒ‡ä»¤åœ°å€
        uintptr_t badvaddr;//ä¿å­˜å¼•å‘å¼‚å¸¸çš„å†…å­˜åœ°å€
        uintptr_t cause;//ä¿å­˜å¼‚å¸¸å‘ç”Ÿçš„åŸå› ï¼Œç”¨äºè¯†åˆ«å…·ä½“çš„ä¸­æ–­æˆ–å¼‚å¸¸ç±»å‹
    };
    ```

    å­˜å‚¨çš„æ˜¯è¿è¡Œåœ¨ç”¨æˆ·æ€æ—¶çš„çŠ¶æ€ã€‚

    ## ç»ƒä¹ 2ï¼šä¸ºæ–°åˆ›å»ºçš„å†…æ ¸çº¿ç¨‹åˆ†é…èµ„æºï¼ˆéœ€è¦ç¼–ç ï¼‰

    åˆ›å»ºä¸€ä¸ªå†…æ ¸çº¿ç¨‹éœ€è¦åˆ†é…å’Œè®¾ç½®å¥½å¾ˆå¤šèµ„æºã€‚kernel_threadå‡½æ•°é€šè¿‡è°ƒç”¨**do_fork**å‡½æ•°å®Œæˆå…·ä½“å†…æ ¸çº¿ç¨‹çš„åˆ›å»ºå·¥ä½œã€‚do_kernelå‡½æ•°ä¼šè°ƒç”¨alloc_procå‡½æ•°æ¥åˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ªè¿›ç¨‹æ§åˆ¶å—ï¼Œä½†alloc_procåªæ˜¯æ‰¾åˆ°äº†ä¸€å°å—å†…å­˜ç”¨ä»¥è®°å½•è¿›ç¨‹çš„å¿…è¦ä¿¡æ¯ï¼Œå¹¶æ²¡æœ‰å®é™…åˆ†é…è¿™äº›èµ„æºã€‚ucoreä¸€èˆ¬é€šè¿‡do_forkå®é™…åˆ›å»ºæ–°çš„å†…æ ¸çº¿ç¨‹ã€‚do_forkçš„ä½œç”¨æ˜¯ï¼Œåˆ›å»ºå½“å‰å†…æ ¸çº¿ç¨‹çš„ä¸€ä¸ªå‰¯æœ¬ï¼Œå®ƒä»¬çš„æ‰§è¡Œä¸Šä¸‹æ–‡ã€ä»£ç ã€æ•°æ®éƒ½ä¸€æ ·ï¼Œä½†æ˜¯å­˜å‚¨ä½ç½®ä¸åŒã€‚å› æ­¤ï¼Œæˆ‘ä»¬**å®é™…éœ€è¦"fork"çš„ä¸œè¥¿å°±æ˜¯stackå’Œtrapframe**ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œéœ€è¦ç»™æ–°å†…æ ¸çº¿ç¨‹åˆ†é…èµ„æºï¼Œå¹¶ä¸”å¤åˆ¶åŸè¿›ç¨‹çš„çŠ¶æ€ã€‚ä½ éœ€è¦å®Œæˆåœ¨kern/process/proc.cä¸­çš„do_forkå‡½æ•°ä¸­çš„å¤„ç†è¿‡ç¨‹ã€‚å®ƒçš„å¤§è‡´æ‰§è¡Œæ­¥éª¤åŒ…æ‹¬ï¼š

    - è°ƒç”¨alloc_procï¼Œé¦–å…ˆè·å¾—ä¸€å—ç”¨æˆ·ä¿¡æ¯å—ã€‚
    - ä¸ºè¿›ç¨‹åˆ†é…ä¸€ä¸ªå†…æ ¸æ ˆã€‚
    - å¤åˆ¶åŸè¿›ç¨‹çš„å†…å­˜ç®¡ç†ä¿¡æ¯åˆ°æ–°è¿›ç¨‹ï¼ˆä½†å†…æ ¸çº¿ç¨‹ä¸å¿…åšæ­¤äº‹ï¼‰
    - å¤åˆ¶åŸè¿›ç¨‹ä¸Šä¸‹æ–‡åˆ°æ–°è¿›ç¨‹
    - å°†æ–°è¿›ç¨‹æ·»åŠ åˆ°è¿›ç¨‹åˆ—è¡¨
    - å”¤é†’æ–°è¿›ç¨‹
    - è¿”å›æ–°è¿›ç¨‹å·

    è¯·åœ¨å®éªŒæŠ¥å‘Šä¸­ç®€è¦è¯´æ˜ä½ çš„è®¾è®¡å®ç°è¿‡ç¨‹ã€‚è¯·å›ç­”å¦‚ä¸‹é—®é¢˜ï¼š

    * è¯·è¯´æ˜ucoreæ˜¯å¦åšåˆ°ç»™æ¯ä¸ªæ–°forkçš„çº¿ç¨‹ä¸€ä¸ªå”¯ä¸€çš„idï¼Ÿè¯·è¯´æ˜ä½ çš„åˆ†æå’Œç†ç”±

**ç­”ï¼š**

##### 1ã€do_forkå‡½æ•°

```c++
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS) {
        goto fork_out;
    }
    ret = -E_NO_MEM;
 
  //åˆ†é…ä¸€ä¸ªPCB
    proc = alloc_proc();
    if (proc == NULL) {
        goto fork_out;
    }
    proc->parent=current;//è®¾ç½®çˆ¶è¿›ç¨‹
    // // åˆ†é…å†…æ ¸æ ˆ
    if (setup_kstack(proc) < 0) {
        goto bad_fork_cleanup_proc;
    }

   // å°†æ‰€æœ‰è™šæ‹Ÿé¡µæ•°æ®å¤åˆ¶è¿‡å»
    if (copy_mm(clone_flags, proc) < 0) {
        goto bad_fork_cleanup_kstack;
    }

   // å¤åˆ¶çº¿ç¨‹çš„çŠ¶æ€ï¼ŒåŒ…æ‹¬å¯„å­˜å™¨ä¸Šä¸‹æ–‡ç­‰ç­‰
    copy_thread(proc, stack, tf);
    bool intr_flag;
    local_intr_save(intr_flag);
        {
        
             // å°†å­è¿›ç¨‹çš„PCBæ·»åŠ è¿›hash listæˆ–è€…list
            proc->pid = get_pid();  // Get a unique PID
            hash_proc(proc);
            list_add(&proc_list, &(proc->list_link));
            nr_process++;  // Increment the number of processes

        // æ¢å¤ä¸­æ–­
        }local_intr_restore(intr_flag);
   
    // å”¤é†’æ–°è¿›ç¨‹ï¼Œè®¾ç½®ä¸ºrunnale
    wakeup_proc(proc);

      // è¿”å›å­è¿›ç¨‹çš„pid
    ret = proc->pid;

fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```

å…·ä½“æ‰§è¡Œæ­¥éª¤å·²ç»å¯¹åº”åˆ°ä»£ç ä¸­çš„ç›¸åº”æ³¨é‡Šä½ç½®ã€‚éœ€è¦æ³¨æ„çš„æ˜¯æŠŠ**è¯¥PCBåŠ å…¥hashé“¾è¡¨æ˜¯ä¸ºäº†åŠ é€Ÿè¯¥è¿›ç¨‹çš„æŸ¥æ‰¾**ã€‚

`do_fork`å‡½æ•°ä¸­çš„`copy_thread`å‡½æ•°ä¼šæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

- å°†`kernel_thread`ä¸­åˆ›å»ºçš„æ–°`trapframe`å†…å®¹å¤åˆ¶å·²æœ‰çš„`tf`ï¼Œå¹¶å‹å…¥è¯¥è¿›ç¨‹è‡ªèº«çš„å†…æ ¸æ ˆã€‚

- è®¾ç½®`trapframe`çš„`a0`å¯„å­˜å™¨å€¼ä¸º0ï¼Œ`esp`å¯„å­˜å™¨å€¼ä¸ºä¼ å…¥çš„`esp`ï¼Œä»¥åŠ`eflags`åŠ ä¸Šä¸­æ–­æ ‡å¿—ä½ã€‚

  > è®¾ç½®a0å¯„å­˜å™¨çš„å€¼ä¸º0ï¼Œæ˜¯å› ä¸ºå­è¿›ç¨‹çš„forkå‡½æ•°è¿”å›çš„å€¼ä¸º0ã€‚

- æœ€åï¼Œè®¾ç½®å­è¿›ç¨‹ä¸Šä¸‹æ–‡çš„`ra`ä¸º`forkret`ï¼Œ`sp`ä¸ºè¯¥`trapframe`çš„åœ°å€ã€‚

##### 2ã€è¯·è¯´æ˜ucoreæ˜¯å¦åšåˆ°ç»™æ¯ä¸ªæ–°forkçš„çº¿ç¨‹ä¸€ä¸ªå”¯ä¸€çš„idï¼Ÿè¯·è¯´æ˜ä½ çš„åˆ†æå’Œç†ç”±

æ¯ä¸ªæ–°forkçš„çº¿ç¨‹éƒ½ä¼šæœ‰ä¸€ä¸ªå”¯ä¸€çš„idï¼›çº¿ç¨‹idç”±get_pid()å‡½æ•°è·å–ã€‚

```c++
static int
get_pid(void) {
    static_assert(MAX_PID > MAX_PROCESS);
    struct proc_struct *proc;
    list_entry_t *list = &proc_list, *le;
    static int next_safe = MAX_PID, last_pid = MAX_PID;
    if (++ last_pid >= MAX_PID) {
        last_pid = 1;
        goto inside;
    }
    if (last_pid >= next_safe) {
    inside:
        next_safe = MAX_PID;
    repeat:
        le = list;
        while ((le = list_next(le)) != list) {
            proc = le2proc(le, list_link);
            if (proc->pid == last_pid) {
                if (++ last_pid >= next_safe) {
                    if (last_pid >= MAX_PID) {
                        last_pid = 1;
                    }
                    next_safe = MAX_PID;
                    goto repeat;
                }
            }
            else if (proc->pid > last_pid && next_safe > proc->pid) {
                next_safe = proc->pid;
            }
        }
    }
    return last_pid;
}
```

- `next_safe`æ˜¯å¤§äºå·²åˆ†é…è¿›ç¨‹idä¸­å¤§äº`last_pid`ä¸­æœ€å°çš„ã€‚åˆ™è¯´æ˜`last_pid`åˆ°`next_safe`ä¹‹é—´åŠ`last_pid`éƒ½æ˜¯å®‰å…¨å¯åˆ†é…çš„PIDã€‚
- åœ¨å‡½æ•°`get_pid`ä¸­ï¼Œå¦‚æœé™æ€æˆå‘˜`last_pid`å°äº`next_safe`ï¼Œåˆ™å½“å‰åˆ†é…çš„`last_pid`ä¸€å®šæ˜¯å®‰å…¨çš„ï¼Œå³å”¯ä¸€çš„PIDã€‚
- ä½†å¦‚æœ`last_pid`å¤§äºç­‰äº`next_safe`ï¼Œæˆ–è€…`last_pid`çš„å€¼è¶…è¿‡`MAX_PID`ï¼Œåˆ™å½“å‰çš„`last_pid`å°±ä¸ä¸€å®šæ˜¯å”¯ä¸€çš„PIDï¼Œæ­¤æ—¶å°±éœ€è¦éå†`proc_list`ï¼Œé‡æ–°å¯¹`last_pid`å’Œ`next_safe`è¿›è¡Œè®¾ç½®ï¼Œä¸ºä¸‹ä¸€æ¬¡çš„`get_pid`è°ƒç”¨æ‰“ä¸‹åŸºç¡€ã€‚
- ä¹‹æ‰€ä»¥åœ¨è¯¥å‡½æ•°ä¸­**ç»´æŠ¤ä¸€ä¸ªåˆæ³•çš„`PID`çš„åŒºé—´**ï¼Œæ˜¯ä¸ºäº†**ä¼˜åŒ–æ—¶é—´æ•ˆç‡**ã€‚å¦‚æœç®€å•çš„æš´åŠ›æœç´¢ï¼Œåˆ™éœ€è¦æœç´¢å¤§éƒ¨åˆ†PIDå’Œæ‰€æœ‰çš„çº¿ç¨‹ï¼Œè¿™ä¼šä½¿è¯¥ç®—æ³•çš„æ—¶é—´æ¶ˆè€—å¾ˆå¤§ï¼Œå› æ­¤ä½¿ç”¨`PID`åŒºé—´æ¥ä¼˜åŒ–ç®—æ³•ã€‚

ä½¿ç”¨è¯¥å‡½æ•°å°±å¯ä»¥æ‰¾åˆ°ä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„idè¾¨è¯†è¿›ç¨‹ã€‚
è¿™æ®µä»£ç æä¾›äº†ä¸€ç§æœºåˆ¶æ¥ä¿å­˜å’Œæ¢å¤ä¸­æ–­çŠ¶æ€ï¼Œé€šå¸¸ç”¨äºéœ€è¦ä¸´æ—¶ç¦ç”¨ä¸­æ–­ä»¥ä¿æŠ¤ä¸´ç•ŒåŒºä»£ç çš„åœºæ™¯ã€‚ä¸‹é¢æ˜¯å¯¹ä»£ç çš„è¯¦ç»†åˆ†æï¼š

## ç»ƒä¹ 3ï¼šç¼–å†™proc_runå‡½æ•°ï¼ˆéœ€è¦ç¼–ç ï¼‰
    proc_runç”¨äºå°†æŒ‡å®šçš„è¿›ç¨‹åˆ‡æ¢åˆ°CPUä¸Šè¿è¡Œã€‚å®ƒçš„å¤§è‡´æ‰§è¡Œæ­¥éª¤åŒ…æ‹¬ï¼š

    - æ£€æŸ¥è¦åˆ‡æ¢çš„è¿›ç¨‹æ˜¯å¦ä¸å½“å‰æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ç›¸åŒï¼Œå¦‚æœç›¸åŒåˆ™ä¸éœ€è¦åˆ‡æ¢ã€‚
    - ç¦ç”¨ä¸­æ–­ã€‚ä½ å¯ä»¥ä½¿ç”¨/kern/sync/sync.hä¸­å®šä¹‰å¥½çš„å®local_intr_save(x)å’Œlocal_intr_restore(x)æ¥å®ç°å…³ã€å¼€ä¸­æ–­ã€‚
    - åˆ‡æ¢å½“å‰è¿›ç¨‹ä¸ºè¦è¿è¡Œçš„è¿›ç¨‹ã€‚
    - åˆ‡æ¢é¡µè¡¨ï¼Œä»¥ä¾¿ä½¿ç”¨æ–°è¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚/libs/riscv.hä¸­æä¾›äº†lcr3(unsigned int cr3)å‡½æ•°ï¼Œå¯å®ç°ä¿®æ”¹CR3å¯„å­˜å™¨å€¼çš„åŠŸèƒ½ã€‚
    - å®ç°ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚/kern/processä¸­å·²ç»é¢„å…ˆç¼–å†™å¥½äº†switch.Sï¼Œå…¶ä¸­å®šä¹‰äº†switch_to()å‡½æ•°ã€‚å¯å®ç°ä¸¤ä¸ªè¿›ç¨‹çš„contextåˆ‡æ¢ã€‚
    - å…è®¸ä¸­æ–­ã€‚

    è¯·å›ç­”å¦‚ä¸‹é—®é¢˜ï¼š

    * åœ¨æœ¬å®éªŒçš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œåˆ›å»ºä¸”è¿è¡Œäº†å‡ ä¸ªå†…æ ¸çº¿ç¨‹ï¼Ÿ

**è§£ç­”ï¼š**

##### 1ã€proc_runå‡½æ•°

```c++
void proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag; 
        struct proc_struct *prev = current;
        local_intr_save(intr_flag); 
        {
            current = proc;
            lcr3(current->cr3);
            switch_to(&(prev->context), &(current->context));
        }
        local_intr_restore(intr_flag);
    }
}
```

`proc_run`å‡½æ•°ä¸­å„ä¸ªæ­¥éª¤çš„å…·ä½“æ“ä½œï¼š

- å°†å½“å‰æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ç”¨ä¸´æ—¶è¿›ç¨‹æ§åˆ¶å—å¯¹è±¡`prev`ä¿å­˜ï¼›

- è°ƒç”¨`local_intr_save(intr_flag)`ä¿æŒå½“å‰ä¸­æ–­çŠ¶æ€åˆ°intr_flagå¹¶ç¦ç”¨ä¸­æ–­ï¼›
    ```c++
    #define local_intr_save(x) \
        do {                   \
            x = __intr_save(); \
        } while (0)
    ```

- å½“å‰è¿›ç¨‹è®¾ä¸ºå¾…è°ƒåº¦çš„è¿›ç¨‹`current = proc`ï¼›

- æ›´æ–°é¡µè¡¨ï¼Œå°†å½“å‰çš„cr3å¯„å­˜å™¨æ”¹ä¸ºéœ€è¦è¿è¡Œè¿›ç¨‹çš„é¡µç›®å½•è¡¨`lcr3(current->cr3)`ã€‚é¡µç›®å½•è¡¨åŒ…å«äº†è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„æ˜ å°„å…³ç³»,å°†å½“å‰è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´æ˜ å°„å…³ç³»åˆ‡æ¢ä¸ºæ–°è¿›ç¨‹çš„æ˜ å°„å…³ç³»ï¼Œå› æ­¤éœ€è¦ç¡®ä¿æŒ‡ä»¤å’Œæ•°æ®çš„åœ°å€è½¬æ¢æ˜¯åŸºäºæ–°è¿›ç¨‹çš„é¡µç›®å½•è¡¨è¿›è¡Œçš„ã€‚

- è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢`switch_to(&(prev->context), &(current->context))`ï¼Œä¿å­˜åŸçº¿ç¨‹çš„å¯„å­˜å™¨ï¼ŒåŒæ—¶æ¢å¤å¾…è°ƒåº¦çº¿ç¨‹çš„å¯„å­˜å™¨ï¼›

- æœ€åï¼Œè°ƒç”¨`local_intr_restore(intr_flag)`æ¢å¤ä¸­æ–­çŠ¶æ€ã€‚
    ```c++
    #define local_intr_restore(x) __intr_restore(x);
    ```

##### 2ã€åœ¨æœ¬å®éªŒçš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œåˆ›å»ºä¸”è¿è¡Œäº†å‡ ä¸ªå†…æ ¸çº¿ç¨‹ï¼Ÿ

å…±åˆ›å»ºä¸”è¿è¡Œäº†ä¸¤ä¸ªå†…æ ¸çº¿ç¨‹`idleproc`å’Œ`initproc`ã€‚

###### ï¼ˆ1ï¼‰åˆ›å»ºå†…æ ¸çº¿ç¨‹

```c++
void proc_init(void) {
    int i;

    // åˆå§‹åŒ–è¿›ç¨‹åˆ—è¡¨
    list_init(&proc_list);
    // éå†å“ˆå¸Œåˆ—è¡¨çš„å¤§å°ï¼Œå¯¹å“ˆå¸Œåˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œåˆå§‹åŒ–
    for (i = 0; i < HASH_LIST_SIZE; i ++) {
        list_init(hash_list + i);
    }

    // åˆ†é…ä¸€ä¸ªè¿›ç¨‹ç»“æ„ç»™ç©ºé—²è¿›ç¨‹ï¼ˆidle processï¼‰ï¼Œå¦‚æœåˆ†é…å¤±è´¥åˆ™è§¦å‘panic
    if ((idleproc = alloc_proc()) == NULL) {
        panic("cannot alloc idleproc.\n");
    }

    // æ£€æŸ¥idle processçš„ä¸Šä¸‹æ–‡ç»“æ„æ˜¯å¦è¢«æ­£ç¡®åˆå§‹åŒ–ä¸ºé›¶
    int *context_mem = (int*) kmalloc(sizeof(struct context)); // åˆ†é…å†…å­˜ç”¨äºæ¯”è¾ƒ
    memset(context_mem, 0, sizeof(struct context)); // å°†åˆ†é…çš„å†…å­˜æ¸…é›¶
    int context_init_flag = memcmp(&(idleproc->context), context_mem, sizeof(struct context)); // æ¯”è¾ƒç©ºé—²è¿›ç¨‹çš„ä¸Šä¸‹æ–‡å’Œæ¸…é›¶çš„å†…å­˜

    // æ£€æŸ¥idle processçš„åç§°æ˜¯å¦è¢«æ­£ç¡®åˆå§‹åŒ–ä¸ºé›¶
    int *proc_name_mem = (int*) kmalloc(PROC_NAME_LEN);
    memset(proc_name_mem, 0, PROC_NAME_LEN);
    int proc_name_flag = memcmp(&(idleproc->name), proc_name_mem, PROC_NAME_LEN);

    if(idleproc->cr3 == boot_cr3 && idleproc->tf == NULL && !context_init_flag
        && idleproc->state == PROC_UNINIT && idleproc->pid == -1 && idleproc->runs == 0
        && idleproc->kstack == 0 && idleproc->need_resched == 0 && idleproc->parent == NULL
        && idleproc->mm == NULL && idleproc->flags == 0 && !proc_name_flag
    ){
        cprintf("alloc_proc() correct!\n");
    }
    
    // è®¾ç½®idle processçš„åŸºæœ¬ä¿¡æ¯ï¼Œå¦‚PIDã€çŠ¶æ€ã€å†…æ ¸æ ˆã€è°ƒåº¦éœ€æ±‚ç­‰
    idleproc->pid = 0;
    idleproc->state = PROC_RUNNABLE;
    idleproc->kstack = (uintptr_t)bootstack;
    idleproc->need_resched = 1;
    set_proc_name(idleproc, "idle"); // è®¾ç½®è¿›ç¨‹åç§°ä¸º"idle"
    nr_process ++; // å¢åŠ è¿›ç¨‹è®¡æ•°

    // å°†å½“å‰è¿›ç¨‹è®¾ç½®ä¸ºç©ºé—²è¿›ç¨‹
    current = idleproc;

    // åˆ›å»ºä¸€ä¸ªå†…æ ¸çº¿ç¨‹ï¼ˆinit processï¼‰æ¥è¿è¡Œinit_mainå‡½æ•°
    int pid = kernel_thread(init_main, "Hello world!!", 0);
    if (pid <= 0) {
        panic("create init_main failed.\n"); // å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œåˆ™è§¦å‘panic
    }

    // æŸ¥æ‰¾å¹¶è®¾ç½®initè¿›ç¨‹çš„æŒ‡é’ˆ
    initproc = find_proc(pid);
    set_proc_name(initproc, "init"); // è®¾ç½®è¿›ç¨‹åç§°ä¸º"init"

    assert(idleproc != NULL && idleproc->pid == 0);
    assert(initproc != NULL && initproc->pid == 1);
}
```

`idleproc`çš„åˆ›å»ºæ­¥éª¤ï¼š

1. **åˆ†é…è¿›ç¨‹ç»“æ„**ï¼šé€šè¿‡`alloc_proc()`å‡½æ•°ä¸ºç©ºé—²è¿›ç¨‹åˆ†é…ä¸€ä¸ªè¿›ç¨‹æ§åˆ¶å—ï¼ˆPCBï¼‰ã€‚

2. **åˆå§‹åŒ–è¿›ç¨‹ç»“æ„**ï¼šå°†åˆ†é…çš„è¿›ç¨‹ç»“æ„è¿›è¡Œåˆå§‹åŒ–ï¼ŒåŒ…æ‹¬è®¾ç½®ä¸€äº›åŸºæœ¬å­—æ®µï¼ˆå¦‚PIDã€çŠ¶æ€ã€å†…æ ¸æ ˆç­‰ï¼‰ä¸ºé»˜è®¤å€¼ã€‚æ­¤æ—¶ï¼Œè¿›ç¨‹é€šå¸¸å¤„äºæœªåˆå§‹åŒ–ï¼ˆ`PROC_UNINIT`ï¼‰çŠ¶æ€ã€‚

3. **æ£€æŸ¥åˆå§‹åŒ–çŠ¶æ€**ï¼šé€šè¿‡æ¯”è¾ƒå’ŒéªŒè¯ï¼Œç¡®ä¿è¿›ç¨‹ç»“æ„ä¸­çš„å…³é”®å­—æ®µï¼ˆå¦‚ä¸Šä¸‹æ–‡å’Œåç§°ï¼‰å·²è¢«æ­£ç¡®åˆå§‹åŒ–ä¸ºé›¶æˆ–ç©ºã€‚

4. **è®¾ç½®ç‰¹å®šå±æ€§**ï¼šä¸ºç©ºé—²è¿›ç¨‹è®¾ç½®ç‰¹å®šçš„å±æ€§ï¼Œè®¾ç½®PIDä¸º0ã€çŠ¶æ€ä¸ºå¯è¿è¡Œï¼ˆ`PROC_RUNNABLE`ï¼‰ã€å†…æ ¸æ ˆæŒ‡å‘æ­£ç¡®çš„ä½ç½®ã€è®¾ç½®è°ƒåº¦éœ€æ±‚ç­‰ã€‚

5. **æ›´æ–°è¿›ç¨‹è®¡æ•°**ï¼šå¢åŠ ç³»ç»Ÿä¸­è¿›ç¨‹çš„æ€»æ•°ã€‚

6. **è®¾ç½®ä¸ºå½“å‰è¿›ç¨‹**ï¼šå°†ç©ºé—²è¿›ç¨‹è®¾ç½®ä¸ºå½“å‰æ­£åœ¨æ‰§è¡Œçš„è¿›ç¨‹ã€‚

`initproc`çš„åˆ›å»ºæ­¥éª¤ï¼š

1. **åˆ›å»ºå†…æ ¸çº¿ç¨‹**ï¼šé€šè¿‡`kernel_thread()`å‡½æ•°åˆ›å»ºä¸€ä¸ªå†…æ ¸çº¿ç¨‹æ¥è¿è¡Œ`init_main()`å‡½æ•°ã€‚

2. **è·å–çº¿ç¨‹PID**ï¼šä»`kernel_thread()`å‡½æ•°çš„è¿”å›å€¼ä¸­è·å–æ–°åˆ›å»ºçš„çº¿ç¨‹çš„PIDï¼ˆè¿›ç¨‹æ ‡è¯†ç¬¦ï¼‰ã€‚

3. **æŸ¥æ‰¾è¿›ç¨‹ç»“æ„**ï¼šä½¿ç”¨è·å–åˆ°çš„PIDï¼Œé€šè¿‡`find_proc()`å‡½æ•°åœ¨è¿›ç¨‹åˆ—è¡¨ä¸­æŸ¥æ‰¾å¯¹åº”çš„è¿›ç¨‹ç»“æ„ã€‚

4. **è®¾ç½®è¿›ç¨‹å±æ€§**ï¼šä¸ºæ–°æ‰¾åˆ°çš„`init`è¿›ç¨‹è®¾ç½®ç‰¹å®šçš„å±æ€§ï¼Œè®¾ç½®PIDä¸º1ã€çŠ¶æ€ç­‰ã€‚

5. **éªŒè¯è¿›ç¨‹ç»“æ„**ï¼šé€šè¿‡æ–­è¨€ï¼ˆ`assert`ï¼‰ç¡®ä¿`init`è¿›ç¨‹çš„ç»“æ„å·²è¢«æ­£ç¡®åˆå§‹åŒ–å’Œåˆ†é…ã€‚


###### ï¼ˆ2ï¼‰è¿è¡Œå†…æ ¸çº¿ç¨‹

1. **è¿è¡Œ`idleproc`**ï¼š`proc_init`å‡½æ•°åœ¨åˆå§‹åŒ–`idleproc`æ—¶ï¼Œ`current = idleproc`å°†å…¶è®¾ç½®ä¸ºå½“å‰è¿›ç¨‹å¼€å§‹è¿è¡Œã€‚åŒæ—¶å°†`idleproc->need_resched`ç½®ä¸º1ï¼Œä»¥ä¾¿é©¬ä¸Šè°ƒç”¨`schedule`å‡½æ•°æ‰¾å…¶ä»–å¤„äºâ€œå°±ç»ªâ€æ€çš„è¿›ç¨‹æ‰§è¡Œã€‚

2. **è¿è¡Œ`initproc`**ï¼šé¦–å…ˆï¼Œ`cpu_idle`åˆ¤æ–­å½“å‰å†…æ ¸çº¿ç¨‹`idleproc->need_resched`æ˜¯å¦ä¸ä¸º0ï¼Œç”±äºä¸Šæ–‡å°†å…¶è®¾ç½®ä¸º1ï¼Œåˆ™è°ƒç”¨`schedule`å‡½æ•°åœ¨`proc_list`é˜Ÿåˆ—ä¸­æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå¤„äºâ€œå°±ç»ªâ€æ€çš„çº¿ç¨‹ï¼ˆç”±äº`proc_list`ä¸­åªæœ‰ä¸¤ä¸ªå†…æ ¸çº¿ç¨‹ï¼Œå› æ­¤åªèƒ½æ‰¾åˆ°`initproc`ï¼‰ï¼Œå¹¶é€šè¿‡`proc_run`å’Œè¿›ä¸€æ­¥çš„`switch_to`å‡½æ•°å®Œæˆä¸¤ä¸ªæ‰§è¡Œç°åœºçš„åˆ‡æ¢ã€‚è‡³æ­¤ï¼Œå°±åˆ‡æ¢åˆ°äº†`initproc`å†…æ ¸è¿›ç¨‹è¿è¡Œã€‚


## æ‰©å±•ç»ƒä¹  Challengeï¼š
è¯´æ˜è¯­å¥local_intr_save(intr_flag);....local_intr_restore(intr_flag);æ˜¯å¦‚ä½•å®ç°å¼€å…³ä¸­æ–­çš„ï¼Ÿ

###### è§£ç­”ï¼š
é¦–å…ˆå…ˆæ‰¾åˆ°å¯¹åº”ä»£ç 
```
#define local_intr_save(x)      do {x = __intr_save(); } while (0)
#define local_intr_restore(x)   __intr_restore(x);

static inline bool __intr_save(void) {
    if (read_csr(sstatus) & SSTATUS_SIE) {
        intr_disable();
        return 1;
    }
    return 0;
}

static inline void __intr_restore(bool flag) {
    if (flag) {
        intr_enable();
    }
}
/* intr_enable - enable irq interrupt */
void intr_enable(void) { set_csr(sstatus, SSTATUS_SIE); }

/* intr_disable - disable irq interrupt */
void intr_disable(void) { clear_csr(sstatus, SSTATUS_SIE); }
```

local_intr_saveå®æ¥å—ä¸€ä¸ªå‚æ•°`x`ï¼Œè¿™ä¸ªå‚æ•°ç”¨äºå­˜å‚¨`__intr_save`å‡½æ•°çš„è¿”å›å€¼ã€‚ `do { x = __intr_save(); } while (0)`ï¼šå®å±•å¼€ä¸ºä¸€ä¸ª`do-while`å¾ªç¯ï¼Œè¿™ä¸ªå¾ªç¯å®é™…ä¸Šåªæ‰§è¡Œä¸€æ¬¡ã€‚è¿™æ ·å†™æ˜¯ä¸ºäº†åœ¨è°ƒç”¨çš„æ—¶å€™ï¼Œè¿™ä¸€æ®µä¸€å®šè¢«å•ç‹¬è§£é‡Šä¸ºä¸€æ¡è¯­å¥æ‰§è¡Œï¼Œ`__intr_save`å‡½æ•°è¢«è°ƒç”¨ï¼Œå…¶è¿”å›å€¼è¢«èµ‹å€¼ç»™å˜é‡`x`ã€‚æ•°ï¼Œå¦‚æœå½“å‰ sstatus å¯„å­˜å™¨çš„ SIE ä½ä¸º 1ï¼ˆå¯ç”¨çŠ¶æ€ï¼‰ï¼Œåˆ™æ‰§è¡Œ intr_disable() ç¦ç”¨ä¸­æ–­ï¼Œå¹¶è¿”å› 1 è¡¨ç¤ºä¸­æ–­åŸæœ¬æ˜¯å¼€å¯çš„ï¼›å¦åˆ™ï¼Œè¿”å› 0 è¡¨ç¤ºä¸­æ–­åŸæœ¬æ˜¯å…³é—­çš„ã€‚intr_disable é€šè¿‡æ¸…é™¤SSTATUS_SIEä½æ¥ç¦ç”¨ä¸­æ–­ï¼Œè€Œ intr_enable é€šè¿‡è®¾ç½®SSTATUS_SIEä½æ¥å¯ç”¨ä¸­æ–­ã€‚local_intr_restore(intr_flag)é€šè¿‡å®'_intr_restore 'æ¢å¤ä¹‹å‰ä¿å­˜çš„ä¸­æ–­çŠ¶æ€ï¼Œå†å¯ç”¨intr_enableçš„å€¼æ¥é‡æ–°å¯ç”¨æˆ–ç¦ç”¨ä¸­æ–­ã€‚

è¿™ä¸¤å¯¹å‡½æ•°å’Œå®æä¾›äº†ä¸€ç§æœºåˆ¶æ¥ä¿å­˜å’Œæ¢å¤ä¸­æ–­çŠ¶æ€ã€‚`__intr_save`å‡½æ•°æ£€æŸ¥æ˜¯å¦éœ€è¦ç¦ç”¨ä¸­æ–­ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ ‡å¿—ã€‚`local_intr_save`å®ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ¥ä¿å­˜ä¸­æ–­çŠ¶æ€ï¼Œå¹¶å°†è¿”å›å€¼å­˜å‚¨åœ¨ä¸€ä¸ªå˜é‡ä¸­ã€‚`__intr_restore`å‡½æ•°æ ¹æ®ä¼ å…¥çš„æ ‡å¿—å†³å®šæ˜¯å¦éœ€è¦é‡æ–°ä½¿èƒ½ä¸­æ–­ã€‚`local_intr_restore`å®ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ¥æ¢å¤ä¸­æ–­çŠ¶æ€ã€‚è¿™ç§æœºåˆ¶ç¡®ä¿åœ¨æ‰§è¡Œè¿›ç¨‹åˆ‡æ¢æ—¶æ—¶ä¸ä¼šè¢«ä¸­æ–­æ‰“æ–­ã€‚
